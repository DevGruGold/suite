import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.58.0'
import { startUsageTracking } from '../_shared/edgeFunctionUsageLogger.ts';

const FUNCTION_NAME = 'n8n-workflow-generator';

interface N8NWorkflow {
  name: string
  description: string
  nodes: any[]
  connections: any
  settings: any
}

interface WorkflowRequest {
  type: 'data-processing' | 'agent-communication' | 'monitoring' | 'content-generation' | 'integration'
  purpose: string
  sources?: string[]
  targets?: string[]
  agents?: string[]
  schedule?: string
  priority?: number
}

serve(async (req) => {
  const usageTracker = startUsageTracking(FUNCTION_NAME, undefined, { method: req.method });

  try {
    const supabase = createClient(
      Deno.env.get('NEXT_PUBLIC_SUPABASE_URL') ?? '',
      Deno.env.get('NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY') ?? ''
    )

    if (req.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const { type, purpose, sources = [], targets = [], agents = [], schedule = '0 */6 * * *', priority = 5 } = await req.json() as WorkflowRequest

    console.log(`Generating ${type} workflow for: ${purpose}`)

    // Generate workflow based on type
    const workflow = generateWorkflowTemplate(type, purpose, sources, targets, agents, schedule, priority)
    
    // Store in Supabase
    const { data: stored, error: storeError } = await supabase
      .from('generated_workflows')
      .insert([{
        name: workflow.name,
        type: type,
        purpose: purpose,
        workflow_data: workflow,
        status: 'generated',
        created_at: new Date().toISOString(),
        ecosystem: 'XMRT'
      }])
      .select()

    if (storeError) {
      console.error('Store error:', storeError)
      throw new Error(`Failed to store workflow: ${storeError.message}`)
    }

    // Log activity
    await supabase.from('eliza_activity_log').insert([{
      agent_name: 'N8N-Workflow-Generator',
      action: 'generate_workflow',
      details: `Generated ${type} workflow: ${workflow.name} for ${purpose}`,
      timestamp: new Date().toISOString(),
      context: { type, purpose, workflow_id: stored?.[0]?.id }
    }])

    await usageTracker.success({ workflow_type: type });
    return new Response(JSON.stringify({
      success: true,
      workflow: workflow,
      id: stored?.[0]?.id,
      message: `Generated ${type} workflow for ${purpose}`,
      timestamp: new Date().toISOString()
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    })

  } catch (error) {
    console.error('N8N Generator error:', error)
    await usageTracker.failure(error.message, 500);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    })
  }
})

function generateWorkflowTemplate(
  type: string, 
  purpose: string, 
  sources: string[], 
  targets: string[], 
  agents: string[],
  schedule: string,
  priority: number
): N8NWorkflow {
  const baseNodes = [
    {
      id: 'trigger',
      name: 'XMRT Schedule Trigger',
      type: 'n8n-nodes-base.cron',
      position: [100, 200],
      parameters: {
        rule: { expression: schedule },
        message: `XMRT ${type} automation`
      }
    },
    {
      id: 'ecosystem_check',
      name: 'XMRT Ecosystem Health Check',
      type: 'n8n-nodes-base.httpRequest',
      position: [300, 200],
      parameters: {
        url: 'https://xmrt-ecosystem.vercel.app/api/index',
        method: 'GET',
        options: {
          timeout: 10000
        }
      }
    }
  ]

  let specificNodes: any[] = []
  
  switch (type) {
    case 'data-processing':
      specificNodes = generateDataProcessingNodes(sources, targets, purpose)
      break
    case 'agent-communication':
      specificNodes = generateAgentCommunicationNodes(agents, purpose)
      break
    case 'monitoring':
      specificNodes = generateMonitoringNodes(targets, purpose)
      break
    case 'content-generation':
      specificNodes = generateContentGenerationNodes(purpose)
      break
    case 'integration':
      specificNodes = generateIntegrationNodes(sources, targets, purpose)
      break
  }

  return {
    name: `XMRT-${type}-${Date.now()}`,
    description: `Autonomous XMRT ${type} workflow for ${purpose}. Generated by XMRT ecosystem.`,
    nodes: [...baseNodes, ...specificNodes],
    connections: generateConnections(baseNodes, specificNodes),
    settings: {
      executionOrder: 'v1',
      saveManualExecutions: true,
      callerPolicy: 'workflowsFromSameOwner',
      timezone: 'UTC',
      errorWorkflow: {
        active: true
      }
    }
  }
}

function generateDataProcessingNodes(sources: string[], targets: string[], purpose: string): any[] {
  return [
    {
      id: 'fetch_xmrt_data',
      name: 'Fetch XMRT Data',
      type: 'n8n-nodes-base.httpRequest',
      position: [500, 200],
      parameters: {
        url: sources[0] || 'https://xmrt-ecosystem.vercel.app/api/agents',
        method: 'GET',
        options: {
          timeout: 15000,
          redirect: {
            followRedirect: true
          }
        }
      }
    },
    {
      id: 'process_xmrt_data',
      name: 'Process XMRT Data',
      type: 'n8n-nodes-base.code',
      position: [700, 200],
      parameters: {
        jsCode: `
// XMRT Ecosystem Data Processing
const inputData = $input.all();
console.log('Processing XMRT data for: ${purpose}');

const processedData = inputData.map(item => {
  const data = item.json;
  return {
    ...data,
    processed_at: new Date().toISOString(),
    xmrt_ecosystem: true,
    processing_purpose: '${purpose}',
    agent_count: Array.isArray(data.agents) ? data.agents.length : 0,
    ecosystem_status: data.status || 'unknown'
  };
});

console.log('Processed', processedData.length, 'XMRT data items');
return processedData;
        `
      }
    },
    {
      id: 'store_xmrt_result',
      name: 'Store XMRT Result',
      type: 'n8n-nodes-base.httpRequest',
      position: [900, 200],
      parameters: {
        url: 'https://vawouugtzwmejxqkeqqj.supabase.co/rest/v1/processed_data',
        method: 'POST',
        headers: {
          'apikey': '{{$env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY}}',
          'Authorization': 'Bearer {{$env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY}}',
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        }
      }
    }
  ]
}

function generateAgentCommunicationNodes(agents: string[], purpose: string): any[] {
  return [
    {
      id: 'xmrt_agent_discovery',
      name: 'XMRT Agent Discovery',
      type: 'n8n-nodes-base.httpRequest',
      position: [500, 200],
      parameters: {
        url: 'https://xmrt-ecosystem.vercel.app/api/agents',
        method: 'GET'
      }
    },
    {
      id: 'suite_ai_discovery',
      name: 'Suite AI Discovery',
      type: 'n8n-nodes-base.httpRequest',
      position: [500, 350],
      parameters: {
        url: 'https://suite.lovable.app/api/agents',
        method: 'GET',
        options: {
          timeout: 10000,
          ignoreHttpStatusErrors: true
        }
      }
    },
    {
      id: 'coordinate_ecosystem_agents',
      name: 'Coordinate Ecosystem Agents',
      type: 'n8n-nodes-base.code',
      position: [700, 275],
      parameters: {
        jsCode: `
// XMRT Multi-Agent Coordination Logic
const ecosystemAgents = $input.first().json || {};
const suiteAgents = $input.last().json || {};

const coordination = {
  timestamp: new Date().toISOString(),
  purpose: '${purpose}',
  ecosystem_agents: ecosystemAgents.agents || [],
  suite_agents: suiteAgents.agents || [],
  coordination_id: 'xmrt_coord_' + Date.now(),
  status: 'coordinating',
  total_agents: (ecosystemAgents.agents?.length || 0) + (suiteAgents.agents?.length || 0)
};

console.log('XMRT Coordination:', coordination);
return [coordination];
        `
      }
    },
    {
      id: 'trigger_xmrt_coordination',
      name: 'Trigger XMRT Coordination',
      type: 'n8n-nodes-base.httpRequest',
      position: [900, 275],
      parameters: {
        url: 'https://xmrt-ecosystem.vercel.app/api/tick',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: {
          'source': 'n8n_workflow',
          'purpose': '${purpose}'
        }
      }
    }
  ]
}

function generateMonitoringNodes(targets: string[], purpose: string): any[] {
  return [
    {
      id: 'xmrt_ecosystem_health',
      name: 'XMRT Ecosystem Health',
      type: 'n8n-nodes-base.httpRequest',
      position: [500, 150],
      parameters: {
        url: 'https://xmrt-ecosystem.vercel.app/api/index',
        method: 'GET'
      }
    },
    {
      id: 'suite_ai_health',
      name: 'Suite AI Health',
      type: 'n8n-nodes-base.httpRequest',
      position: [500, 250],
      parameters: {
        url: 'https://suite.lovable.app/health',
        method: 'GET',
        options: {
          timeout: 10000,
          ignoreHttpStatusErrors: true
        }
      }
    },
    {
      id: 'analyze_xmrt_health',
      name: 'Analyze XMRT Health',
      type: 'n8n-nodes-base.code',
      position: [700, 200],
      parameters: {
        jsCode: `
// XMRT Health Analysis
const ecosystemHealth = $input.first().json || {};
const suiteHealth = $input.last().json || {};

const analysis = {
  timestamp: new Date().toISOString(),
  purpose: '${purpose}',
  ecosystem: {
    status: ecosystemHealth.status || 'unknown',
    version: ecosystemHealth.version || 'unknown',
    healthy: ecosystemHealth.status === 'healthy'
  },
  suite_ai: {
    status: suiteHealth.status || 'unknown',
    healthy: suiteHealth.ok || false
  },
  overall_health: (ecosystemHealth.status === 'healthy') && (suiteHealth.ok === true),
  monitoring_id: 'xmrt_monitor_' + Date.now()
};

console.log('XMRT Health Analysis:', analysis);
return [analysis];
        `
      }
    },
    {
      id: 'health_alert',
      name: 'XMRT Health Alert',
      type: 'n8n-nodes-base.if',
      position: [900, 200],
      parameters: {
        conditions: {
          boolean: [
            {
              value1: '={{$json.overall_health}}',
              value2: true,
              operation: 'notEqual'
            }
          ]
        }
      }
    }
  ]
}

function generateContentGenerationNodes(purpose: string): any[] {
  return [
    {
      id: 'xmrt_content_generator',
      name: 'XMRT Content Generator',
      type: 'n8n-nodes-base.code',
      position: [500, 200],
      parameters: {
        jsCode: `
// XMRT Content Generation
const timestamp = new Date().toISOString();
const contentId = 'xmrt_content_' + Date.now();

const content = {
  id: contentId,
  purpose: '${purpose}',
  generated_at: timestamp,
  content_type: 'xmrt_ecosystem_generated',
  ecosystem: 'XMRT',
  data: {
    title: 'Generated Content for ${purpose}',
    description: 'Automatically generated content for XMRT ecosystem',
    metadata: {
      generator: 'XMRT N8N Workflow',
      ecosystem_version: '2.0',
      generation_purpose: '${purpose}'
    },
    content_body: generateXMRTContent('${purpose}')
  }
};

function generateXMRTContent(purpose) {
  const templates = {
    'agent-coordination': 'Multi-agent coordination content for XMRT ecosystem',
    'monitoring': 'System monitoring and health analysis content',
    'integration': 'Ecosystem integration and synchronization content',
    'automation': 'Automated workflow and process content',
    'default': 'General XMRT ecosystem content'
  };
  
  return templates[purpose] || templates['default'];
}

console.log('Generated XMRT content:', content);
return [content];
        `
      }
    },
    {
      id: 'store_xmrt_content',
      name: 'Store XMRT Content',
      type: 'n8n-nodes-base.httpRequest',
      position: [700, 200],
      parameters: {
        url: 'https://vawouugtzwmejxqkeqqj.supabase.co/rest/v1/generated_content',
        method: 'POST',
        headers: {
          'apikey': '{{$env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY}}',
          'Authorization': 'Bearer {{$env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY}}',
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        }
      }
    }
  ]
}

function generateIntegrationNodes(sources: string[], targets: string[], purpose: string): any[] {
  return [
    {
      id: 'xmrt_integration_sync',
      name: 'XMRT Integration Sync',
      type: 'n8n-nodes-base.code',
      position: [500, 200],
      parameters: {
        jsCode: `
// XMRT Integration Sync
const sync = {
  sync_id: 'xmrt_sync_' + Date.now(),
  purpose: '${purpose}',
  sources: ${JSON.stringify(sources)},
  targets: ${JSON.stringify(targets)},
  sync_time: new Date().toISOString(),
  status: 'syncing',
  ecosystem: 'XMRT',
  integration_type: 'cross_repository'
};

console.log('XMRT Integration Sync:', sync);
return [sync];
        `
      }
    },
    {
      id: 'execute_integration',
      name: 'Execute XMRT Integration',
      type: 'n8n-nodes-base.httpRequest',
      position: [700, 200],
      parameters: {
        url: 'https://xmrt-ecosystem.vercel.app/api/tick',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: {
          'integration_sync': true,
          'purpose': '${purpose}',
          'sources': sources,
          'targets': targets
        }
      }
    }
  ]
}

function generateConnections(baseNodes: any[], specificNodes: any[]): any {
  const connections: any = {}
  
  // Connect base flow
  connections['XMRT Schedule Trigger'] = { main: [['XMRT Ecosystem Health Check']] }
  
  if (specificNodes.length > 0) {
    connections['XMRT Ecosystem Health Check'] = { main: [[specificNodes[0].name]] }
    
    // Connect specific nodes in sequence
    for (let i = 0; i < specificNodes.length - 1; i++) {
      connections[specificNodes[i].name] = { main: [[specificNodes[i + 1].name]] }
    }
  }
  
  return connections
}
