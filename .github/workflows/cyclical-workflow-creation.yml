name: 'Autonomous Workflow Creation Cycle'

on:
  schedule:
    - cron: '0 */8 * * *'  # Every 8 hours
  workflow_dispatch:
    inputs:
      workflow_type:
        description: 'Type of workflow to generate'
        required: true
        default: 'agent-communication'
        type: choice
        options:
          - 'data-processing'
          - 'agent-communication'
          - 'monitoring'
          - 'content-generation'
          - 'integration'
      purpose:
        description: 'Purpose of the workflow'
        required: true
        default: 'Autonomous XMRT ecosystem coordination'
      priority:
        description: 'Workflow priority (1-10)'
        required: false
        default: '5'
        type: string

env:
  SUPABASE_URL: https://vawouugtzwmejxqkeqqj.supabase.co
  SUPABASE_KEY: sb_publishable_yIaroctFhoYStx0f9XajBg_zhpuVulw

jobs:
  generate-workflows:
    runs-on: ubuntu-latest
    name: 'Generate XMRT Autonomous Workflows'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Generate Workflow Parameters
        id: generate-workflow
        run: |
          echo "üöÄ Generating XMRT autonomous workflow parameters..."
          
          # Determine workflow parameters
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            WORKFLOW_TYPE="${{ github.event.inputs.workflow_type }}"
            PURPOSE="${{ github.event.inputs.purpose }}"
            PRIORITY="${{ github.event.inputs.priority }}"
          else
            # Scheduled run - cycle through different types
            HOUR=$(date +%H)
            case $((HOUR % 5)) in
              0) WORKFLOW_TYPE="agent-communication" ;;
              1) WORKFLOW_TYPE="monitoring" ;;
              2) WORKFLOW_TYPE="data-processing" ;;
              3) WORKFLOW_TYPE="integration" ;;
              4) WORKFLOW_TYPE="content-generation" ;;
            esac
            PURPOSE="Scheduled XMRT ecosystem $WORKFLOW_TYPE automation"
            PRIORITY="5"
          fi
          
          echo "workflow_type=$WORKFLOW_TYPE" >> $GITHUB_OUTPUT
          echo "purpose=$PURPOSE" >> $GITHUB_OUTPUT
          echo "priority=$PRIORITY" >> $GITHUB_OUTPUT
          
          echo "Generated parameters:"
          echo "  Type: $WORKFLOW_TYPE"
          echo "  Purpose: $PURPOSE"
          echo "  Priority: $PRIORITY"
          
      - name: Call N8N Workflow Generator
        id: call-generator
        continue-on-error: true
        run: |
          echo "üì° Calling XMRT N8N Workflow Generator..."
          
          # Construct the request payload
          PAYLOAD=$(cat << EOF
          {
            "type": "${{ steps.generate-workflow.outputs.workflow_type }}",
            "purpose": "${{ steps.generate-workflow.outputs.purpose }}",
            "sources": ["https://xmrt-ecosystem.vercel.app/api/agents", "https://suite.lovable.app/api/health"],
            "targets": ["https://vawouugtzwmejxqkeqqj.supabase.co/rest/v1/generated_workflows"],
            "agents": ["eliza", "security-guardian", "defi-specialist", "community-manager"],
            "schedule": "0 */6 * * *",
            "priority": ${{ steps.generate-workflow.outputs.priority }}
          }
          EOF
          )
          
          echo "Request payload: $PAYLOAD"
          
          # Make the API call with timeout and error handling
          RESPONSE=$(curl -s --max-time 30 -X POST \
            "https://vawouugtzwmejxqkeqqj.supabase.co/functions/v1/n8n-workflow-generator" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo '{"success": false, "error": "API call failed"}')
          
          echo "API Response: $RESPONSE"
          
          # Parse response with error handling
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false' 2>/dev/null || echo "false")
          WORKFLOW_ID=$(echo "$RESPONSE" | jq -r '.id // "none"' 2>/dev/null || echo "none")
          ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error // "No error details"' 2>/dev/null || echo "Parse error")
          
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "workflow_id=$WORKFLOW_ID" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MSG" >> $GITHUB_OUTPUT
          echo "response=$RESPONSE" >> $GITHUB_OUTPUT
          
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ Workflow generation successful"
          else
            echo "‚ö†Ô∏è Workflow generation failed: $ERROR_MSG"
            echo "Continuing with fallback workflow creation..."
          fi
          
      - name: Create Fallback Workflow
        if: steps.call-generator.outputs.success != 'true'
        id: fallback-workflow
        run: |
          echo "üîÑ Creating fallback XMRT workflow..."
          
          # Create a simple fallback workflow definition
          FALLBACK_WORKFLOW=$(cat << 'EOF'
          {
            "name": "XMRT-fallback-${{ steps.generate-workflow.outputs.workflow_type }}-$(date +%s)",
            "type": "${{ steps.generate-workflow.outputs.workflow_type }}",
            "description": "Fallback XMRT workflow created when API unavailable",
            "purpose": "${{ steps.generate-workflow.outputs.purpose }}",
            "created_by": "GitHub Actions Fallback",
            "ecosystem": "XMRT",
            "status": "fallback_created"
          }
          EOF
          )
          
          echo "Fallback workflow created: $FALLBACK_WORKFLOW"
          echo "fallback_created=true" >> $GITHUB_OUTPUT

      - name: Log Workflow Creation
        if: always()
        run: |
          echo "üìä Logging XMRT workflow creation results..."
          
          if [ "${{ steps.call-generator.outputs.success }}" = "true" ]; then
            echo "‚úÖ XMRT workflow created successfully via API!"
            echo "Workflow ID: ${{ steps.call-generator.outputs.workflow_id }}"
            echo "Type: ${{ steps.generate-workflow.outputs.workflow_type }}"
            echo "Purpose: ${{ steps.generate-workflow.outputs.purpose }}"
          elif [ "${{ steps.fallback-workflow.outputs.fallback_created }}" = "true" ]; then
            echo "üîÑ XMRT fallback workflow created!"
            echo "Reason: API call failed - ${{ steps.call-generator.outputs.error_message }}"
          else
            echo "‚ö†Ô∏è Workflow creation completed with limitations"
          fi
          
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

  generate-gemini-agent:
    runs-on: ubuntu-latest
    name: 'Generate XMRT Gemini Agent'
    needs: generate-workflows
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Generate Agent Parameters
        id: generate-agent
        run: |
          echo "ü§ñ Generating XMRT Gemini agent parameters..."
          
          # Determine agent parameters
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            AGENT_TYPE="specialist"
            DOMAIN="${{ github.event.inputs.workflow_type }}"
            PURPOSE="Specialized agent for ${{ github.event.inputs.purpose }}"
          else
            # Scheduled run - create complementary agent
            HOUR=$(date +%H)
            case $((HOUR % 6)) in
              0) AGENT_TYPE="coordinator"; DOMAIN="ecosystem-management" ;;
              1) AGENT_TYPE="monitor"; DOMAIN="system-health" ;;
              2) AGENT_TYPE="analyst"; DOMAIN="performance-analysis" ;;
              3) AGENT_TYPE="executor"; DOMAIN="workflow-automation" ;;
              4) AGENT_TYPE="integrator"; DOMAIN="cross-platform" ;;
              5) AGENT_TYPE="specialist"; DOMAIN="optimization" ;;
            esac
            PURPOSE="Autonomous $DOMAIN management for XMRT ecosystem"
          fi
          
          echo "agent_type=$AGENT_TYPE" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "purpose=$PURPOSE" >> $GITHUB_OUTPUT
          
          echo "Generated agent parameters:"
          echo "  Type: $AGENT_TYPE"
          echo "  Domain: $DOMAIN"
          echo "  Purpose: $PURPOSE"
          
      - name: Call Gemini Agent Creator
        id: call-creator
        continue-on-error: true
        run: |
          echo "üß† Calling XMRT Gemini Agent Creator..."
          
          # Construct the request payload
          PAYLOAD=$(cat << EOF
          {
            "agent_type": "${{ steps.generate-agent.outputs.agent_type }}",
            "domain": "${{ steps.generate-agent.outputs.domain }}",
            "purpose": "${{ steps.generate-agent.outputs.purpose }}",
            "integration_points": [
              "https://xmrt-ecosystem.vercel.app/api/*",
              "https://suite.lovable.app/*",
              "https://vawouugtzwmejxqkeqqj.supabase.co/rest/v1/*"
            ],
            "memory_context": "XMRT ecosystem shared memory with Suite AI integration",
            "xmrt_role": "Autonomous ${{ steps.generate-agent.outputs.agent_type }} for XMRT ecosystem"
          }
          EOF
          )
          
          echo "Request payload: $PAYLOAD"
          
          # Make the API call
          RESPONSE=$(curl -s --max-time 30 -X POST \
            "https://vawouugtzwmejxqkeqqj.supabase.co/functions/v1/gemini-agent-creator" \
            -H "Authorization: Bearer ${{ env.SUPABASE_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo '{"success": false, "error": "API call failed"}')
          
          echo "API Response: $RESPONSE"
          
          # Parse response
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false' 2>/dev/null || echo "false")
          AGENT_ID=$(echo "$RESPONSE" | jq -r '.id // "none"' 2>/dev/null || echo "none")
          AGENT_NAME=$(echo "$RESPONSE" | jq -r '.agent.name // "none"' 2>/dev/null || echo "none")
          
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT
          echo "agent_name=$AGENT_NAME" >> $GITHUB_OUTPUT
          
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ Agent creation successful"
          else
            echo "‚ö†Ô∏è Agent creation failed, continuing with fallback"
          fi

      - name: Log Agent Creation
        if: always()
        run: |
          echo "üìä Logging XMRT agent creation results..."
          
          if [ "${{ steps.call-creator.outputs.success }}" = "true" ]; then
            echo "‚úÖ XMRT Gemini agent created successfully!"
            echo "Agent ID: ${{ steps.call-creator.outputs.agent_id }}"
            echo "Agent Name: ${{ steps.call-creator.outputs.agent_name }}"
            echo "Type: ${{ steps.generate-agent.outputs.agent_type }}"
            echo "Domain: ${{ steps.generate-agent.outputs.domain }}"
          else
            echo "üîÑ XMRT agent creation completed with fallback handling"
          fi

  trigger-coordination:
    runs-on: ubuntu-latest
    name: 'Trigger XMRT Ecosystem Coordination'
    needs: [generate-workflows, generate-gemini-agent]
    if: always()
    
    steps:
      - name: Trigger XMRT Coordination
        continue-on-error: true
        run: |
          echo "üîÑ Triggering XMRT ecosystem coordination..."
          
          # Trigger XMRT ecosystem coordination
          COORD_RESPONSE=$(curl -s --max-time 20 -X POST \
            "https://xmrt-ecosystem.vercel.app/api/tick" \
            -H "Content-Type: application/json" \
            -d '{
              "source": "autonomous_workflow_creation",
              "trigger_reason": "Workflow generation cycle completed"
            }' || echo "Failed to trigger coordination")
          
          echo "Coordination response: $COORD_RESPONSE"

      - name: Update Ecosystem Status
        if: always()
        run: |
          echo "üìä Updating XMRT ecosystem status..."
          echo "‚úÖ XMRT autonomous generation cycle completed!"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Status: SUCCESS"
